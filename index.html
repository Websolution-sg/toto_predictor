<!DOCTYPE html>
<html lang="en">
<head> 
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Singapore TOTO Predictor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font: 16px/1.5 Arial; padding: 20px; max-width: 600px; margin: auto; }
    select, button, input { font-size: 1em; margin: 0.5em 0; }
    canvas { max-width: 100%; }
  </style>
</head>
<body>
  <h1>Singapore TOTO Predictor</h1>
  <p id="recentResult">RECENT RESULT: Loading...</p>
  <p>By default, the previous lottery result is selected:</p>
  <div>
    <select id="base1"></select>
    <select id="base2"></select>
    <select id="base3"></select>
    <select id="base4"></select>
    <select id="base5"></select>
    <select id="base6"></select>
  </div>

  <div>
    <label>Additional Number:</label><br/>
    <select id="additional"></select>
  </div>

  <div>
    <label>Select draw range:</label><br/>
    <select id="drawRange">
      <option value="20">Last 20</option>
      <option value="50">Last 50</option>
      <option value="100">Last 100</option>
    </select>
  </div>

  <div>
    <label>System Type:</label><br/>
    <select id="systemType">
      <option value="6">System 6 </option>
      <option value="7">System 7 </option>
    </select>
  </div>

  <label><input type="checkbox" id="includeAdd"/> Include additional number</label><br/>
  <label><input type="checkbox" id="showAnalytics" checked/> Show detailed analytics</label><br/>
  <button onclick="predict()">Predict</button>

  <h2>Results</h2>
  <div id="results"></div>
  <div id="analytics" style="margin-top: 20px;"></div>
  <canvas id="freqChart"></canvas>

<script>
let historical = [];
let chartInstance = null;

// Enhanced cache-busting with multiple parameters to ensure fresh CSV data
const cacheBuster = new Date().getTime();
const randomId = Math.random().toString(36).substring(7);
const csvUrl = `totoResult.csv?v=${cacheBuster}&r=${randomId}&nocache=${Date.now()}`;

console.log('🔄 Fetching CSV from:', csvUrl);
fetch(csvUrl, {
  cache: 'no-cache',
  headers: {
    'Cache-Control': 'no-cache, no-store, must-revalidate',
    'Pragma': 'no-cache',
    'Expires': '0'
  }
})
  .then(response => response.text())
  .then(text => {
    historical = text.trim().split('\n').map(line => line.split(',').map(Number));
    for (let i = 1; i <= 49; i++) {
      ['base1', 'base2', 'base3', 'base4', 'base5', 'base6', 'additional'].forEach(id => {
        const opt = document.createElement('option');
        opt.value = opt.textContent = i;
        document.getElementById(id).append(opt);
      });
    }
    const recent = historical[0];
    ['base1', 'base2', 'base3', 'base4', 'base5', 'base6'].forEach((id, idx) => {
      document.getElementById(id).value = recent[idx];
    });
    document.getElementById('additional').value = recent[6];
    document.getElementById('includeAdd').checked = false;
    const today = new Date();
    const dateStr = today.toLocaleDateString('en-SG', { day: '2-digit', month: '2-digit', year: 'numeric' });
    updateLatestResult(recent.slice(0, 6), recent[6], dateStr);
  })
  .catch(error => {
    alert("Failed to load historical data.");
    console.error(error);
  });

function updateLatestResult(winningNumbers, additionalNumber, drawDate = null) {
  const resultText = `${winningNumbers.join(',')}(${additionalNumber})`;
  const resultElement = document.getElementById('recentResult');
  if (resultElement) {
    resultElement.textContent = `RECENT RESULT: ${resultText}${drawDate ? ' - ' + drawDate : ''}`;
  }
}

function hasDuplicates(arr) {
  return new Set(arr).size !== arr.length;
}

function predict() {
  const bases = getSelectedBases();
  if (hasDuplicates(bases)) {
    alert("Duplicate base numbers selected. Please choose unique numbers.");
    return;
  }
  
  // Check if we should use historical match first
  const hasHistoricalMatch = checkHistoricalAndMaybePredict();
  if (hasHistoricalMatch) return;
  
  // Always use Enhanced Analysis method (best performance)
  runEnhancedPrediction();
}

function getSelectedBases() {
  return ['base1', 'base2', 'base3', 'base4', 'base5', 'base6']
    .map(id => parseInt(document.getElementById(id).value))
    .sort((a, b) => a - b);
}

function arraysEqual(a, b) {
  return a.length === b.length && a.every((val, index) => val === b[index]);
}

function checkHistoricalAndMaybePredict() {
  const bases = getSelectedBases();
  const mostRecentDraw = historical[0].slice(0, 6).sort((a, b) => a - b);
  if (arraysEqual(bases, mostRecentDraw)) return false;
  for (let i = historical.length - 1; i > 0; i--) {
    const draw = historical[i].slice(0, 6).sort((a, b) => a - b);
    if (arraysEqual(draw, mostRecentDraw)) continue;
    if (arraysEqual(draw, bases)) {
      const prevDraw = historical[i - 1];
      calculateScoresAndDisplay(prevDraw.slice(0, 6), prevDraw[6]);
      return true;
    }
  }
  return false;
}

function calculateScoresAndDisplay(numbers, additional = null) {
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  const freq = Array(50).fill(0);
  const compat = Array(50).fill(0);
  draws.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => freq[n]++);
    numbers.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n]++);
      }
    });
  });
  const scores = numbers.map(n => freq[n] + compat[n]);
  displayPredictedNumbers(numbers, additional, scores, freq, compat, 'Historical Pattern Match');
}

function runFrequencyCompatibilityPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  const freq = Array(50).fill(0);
  const compat = Array(50).fill(0);
  draws.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => freq[n]++);
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n]++);
      }
    });
  });
  const suggestions = freq.map((count, n) => ({ n, count, compat: compat[n] }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => (b.compat + b.count) - (a.compat + a.count) || b.count - a.count || a.n - b.n)
    .slice(0, 6);
  const scores = suggestions.map(o => o.count + o.compat);
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat, 'Frequency + Compatibility Analysis');
}

// Enhanced Prediction - Combines multiple factors with weighted analysis
function runEnhancedPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  
  const freq = Array(50).fill(0);
  const compat = Array(50).fill(0);
  const weighted = Array(50).fill(0);
  
  draws.forEach((draw, index) => {
    const weight = Math.exp(-index * 0.03); // Recent draws weighted higher
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    
    pool.forEach(n => {
      freq[n]++;
      weighted[n] += weight;
    });
    
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n] += weight);
      }
    });
  });
  
  const suggestions = freq.map((count, n) => ({ 
    n, 
    freq: count,
    compat: compat[n],
    weighted: weighted[n],
    score: count + compat[n] + weighted[n] * 0.5
  }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => b.score - a.score || a.n - b.n)
    .slice(0, 6);
    
  const scores = suggestions.map(o => o.score);
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat, 'Enhanced Analysis (Freq + Compat + Weighted)');
}

// Weighted Recent Prediction - Recent draws count more
function runWeightedPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  
  const weighted = Array(50).fill(0);
  const compat = Array(50).fill(0);
  
  draws.forEach((draw, index) => {
    const weight = 1 / (index + 1); // Linear decay
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    
    pool.forEach(n => weighted[n] += weight);
    
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n] += weight);
      }
    });
  });
  
  const suggestions = weighted.map((weight, n) => ({ 
    n, 
    weight, 
    compat: compat[n],
    score: weight + compat[n]
  }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => b.score - a.score || a.n - b.n)
    .slice(0, 6);
    
  const scores = suggestions.map(o => o.score);
  const freq = suggestions.map(o => o.weight);
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat, 'Weighted Recent Analysis');
}

// Hot/Cold Analysis - Trending numbers
function runHotColdPrediction() {
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const recentDraws = historical.slice(0, Math.floor(range / 2));
  const olderDraws = historical.slice(Math.floor(range / 2), range);
  
  const recentFreq = Array(50).fill(0);
  const olderFreq = Array(50).fill(0);
  
  recentDraws.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => recentFreq[n]++);
  });
  
  olderDraws.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => olderFreq[n]++);
  });
  
  const suggestions = recentFreq.map((recent, n) => ({
    n,
    recent,
    older: olderFreq[n],
    trend: recent - olderFreq[n],
    score: recent + Math.max(0, recent - olderFreq[n]) * 0.5
  }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => b.score - a.score || a.n - b.n)
    .slice(0, 6);
    
  const scores = suggestions.map(o => o.score);
  const freq = suggestions.map(o => o.recent);
  const compat = suggestions.map(o => o.trend);
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat, 'Hot/Cold Trend Analysis');
}

// ENHANCEMENT 1: Enhanced Combined Analysis
function runEnhancedPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  
  const freq = Array(50).fill(0);
  const compat = Array(50).fill(0);
  const hotness = Array(50).fill(0);
  const weighted = Array(50).fill(0);
  
  draws.forEach((draw, index) => {
    const weight = Math.exp(-index * 0.05); // Recent draws weighted higher
    const recentBonus = index < range * 0.3 ? 2 : 1; // Extra bonus for very recent
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    
    pool.forEach(n => {
      freq[n]++;
      weighted[n] += weight;
      hotness[n] += recentBonus;
    });
    
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => {
          compat[n]++;
        });
      }
    });
  });
  
  const suggestions = freq.map((count, n) => ({ 
    n, 
    freq: count, 
    compat: compat[n],
    weighted: weighted[n],
    hotness: hotness[n],
    score: count + compat[n] + weighted[n] * 0.5 + hotness[n] * 0.3
  }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => b.score - a.score || a.n - b.n);
    
  // Get system type (6 or 7 numbers)
  const systemType = parseInt(document.getElementById('systemType').value);
  const finalSuggestions = suggestions.slice(0, systemType);
    
  const scores = finalSuggestions.map(o => Math.round(o.score));
  displayPredictedNumbers(finalSuggestions.map(o => o.n), null, scores, freq, compat, '', finalSuggestions);
}

// ENHANCEMENT 2: Weighted Recent Analysis
function runWeightedPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  
  const weighted = Array(50).fill(0);
  const compat = Array(50).fill(0);
  
  draws.forEach((draw, index) => {
    const weight = Math.exp(-index * 0.1); // Exponential decay for older draws
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    
    pool.forEach(n => weighted[n] += weight);
    
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n] += weight);
      }
    });
  });
  
  const suggestions = weighted.map((weight, n) => ({ 
    n, 
    weight: weight, 
    compat: compat[n],
    score: weight + compat[n] * 1.5
  }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => b.score - a.score || a.n - b.n)
    .slice(0, 6);
    
  const scores = suggestions.map(o => Math.round(o.score * 10) / 10);
  const freq = weighted; // Use weighted as freq for display
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat, 'Weighted Recent Draw Analysis');
}

// ENHANCEMENT 3: Hot/Cold Number Analysis
function runHotColdPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  
  const recentRange = Math.floor(range * 0.3);
  const recent = draws.slice(0, recentRange);
  const older = draws.slice(recentRange);
  
  const recentFreq = Array(50).fill(0);
  const olderFreq = Array(50).fill(0);
  const compat = Array(50).fill(0);
  
  recent.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => recentFreq[n]++);
  });
  
  older.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => olderFreq[n]++);
  });
  
  draws.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n]++);
      }
    });
  });
  
  const suggestions = recentFreq.map((recent, n) => {
    const older = olderFreq[n];
    const trend = recent - (older * (recentRange / (range - recentRange))); // Normalize for different periods
    const temperature = trend > 0 ? 'hot' : trend < 0 ? 'cold' : 'neutral';
    const hotBonus = trend > 0 ? trend * 2 : 0;
    
    return { 
      n, 
      recent: recent,
      trend: trend,
      temperature: temperature,
      compat: compat[n],
      score: recent + compat[n] + hotBonus
    };
  })
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => b.score - a.score || a.n - b.n)
    .slice(0, 6);
    
  const scores = suggestions.map(o => Math.round(o.score));
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, recentFreq, compat, 'Hot/Cold Number Analysis', suggestions);
}

function displayPredictedNumbers(numbers, additional = null, scores, freq, compat, methodName = 'Analysis', extraData = null) {
  const rs = document.getElementById('results');
  const analytics = document.getElementById('analytics');
  const showAnalytics = document.getElementById('showAnalytics').checked;
  const systemType = document.getElementById('systemType').value;
  
  const sorted = numbers.map((n, i) => ({ n, score: scores[i], freq: freq[n], compat: compat[n] }))
    .sort((a, b) => a.n - b.n);
  const sortedNumbers = sorted.map(o => o.n);
  const sortedScores = sorted.map(o => o.score);
  const sortedFreq = sorted.map(o => o.freq);
  const sortedCompat = sorted.map(o => o.compat);
  
  // Main results display with system type info
  const systemInfo = '';

  rs.innerHTML = `
    <h3>Predicted Numbers:</h3>
    <p style="font-size: 1.2em; font-weight: bold; color: #2c5aa0;">${sortedNumbers.join(', ')}</p>
    <p style="margin-top: 10px; font-size: 0.95em;">${systemInfo}</p>
    ${additional ? `<p><strong>Additional Number:</strong> ${additional}</p>` : ''}
  `;
  
  // Analytics display
  if (showAnalytics) {
    let analyticsHtml = `
      <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-top: 10px;">
        <h4>📊 Detailed Analytics (${methodName})</h4>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px;">
    `;
    
    sortedNumbers.forEach((num, i) => {
      let extraInfo = '';
      if (extraData && extraData[numbers.indexOf(num)]) {
        const data = extraData[numbers.indexOf(num)];
        if (data.temperature) {
          extraInfo = `<br>🌡️ ${data.temperature.toUpperCase()} (${data.trend > 0 ? '+' : ''}${data.trend.toFixed(1)})`;
        } else if (data.weighted) {
          extraInfo = `<br>⚖️ Weighted: ${data.weighted.toFixed(1)}`;
        }
      }
      
      analyticsHtml += `
        <div style="background: white; padding: 10px; border-radius: 5px; border-left: 4px solid #2c5aa0;">
          <strong>Number ${num}</strong><br>
          📈 Score: ${sortedScores[i]}<br>
          🔢 Frequency: ${Math.round(sortedFreq[i] * 10) / 10}<br>
          🤝 Compatibility: ${Math.round(sortedCompat[i] * 10) / 10}${extraInfo}
        </div>
      `;
    });
    
    analyticsHtml += `</div>`;
    
    // Add method explanation
    const explanations = {
      'Frequency + Compatibility Analysis': 'Original algorithm analyzing how often numbers appear and their compatibility with selected numbers.',
      'Weighted Recent Draw Analysis': 'Gives more importance to recent draws using exponential decay weighting.',
      'Hot/Cold Number Analysis': 'Identifies trending numbers by comparing recent vs historical frequency.',
    };
    
    if (explanations[methodName]) {
      analyticsHtml += `
        <div style="background: #e8f4f8; padding: 10px; border-radius: 5px; margin-top: 10px;">
          <strong>📋 Method Explanation:</strong><br>
          ${explanations[methodName]}
        </div>
      `;
    }
    
    // Add prediction confidence
    const avgScore = sortedScores.reduce((a, b) => a + b, 0) / sortedScores.length;
    const maxPossibleScore = Math.max(...scores);
    const confidence = Math.round((avgScore / maxPossibleScore) * 100);
    
    analyticsHtml += `
      <div style="background: #f0f8e8; padding: 10px; border-radius: 5px; margin-top: 10px;">
        <strong>🎯 Prediction Confidence:</strong> ${confidence}%<br>
        <strong>📊 Average Score:</strong> ${avgScore.toFixed(1)}<br>
        <strong>📈 Score Range:</strong> ${Math.min(...sortedScores)} - ${Math.max(...sortedScores)}
      </div>
    `;
    
    // Add System 7 benefit explanation
    if (systemType === '7') {
      analyticsHtml += `
        <div style="background: #e8f8e8; padding: 10px; border-radius: 5px; margin-top: 10px; border-left: 4px solid #28a745;">
          <strong>🎯 System 7 Advantage:</strong><br>
          By selecting 7 numbers instead of 6, you significantly increase your winning chances:<br>
          • More combinations covered (7 vs 6)<br>
          • Higher probability of matching winning numbers<br>
        </div>
      `;
    }
    
    analyticsHtml += `</div>`;
    analytics.innerHTML = analyticsHtml;
  } else {
    analytics.innerHTML = '';
  }
  
  // Chart display
  const ctx = document.getElementById('freqChart').getContext('2d');
  if (chartInstance) chartInstance.destroy();
  chartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: sortedNumbers.map((n, i) => `${n} (F: ${Math.round(sortedFreq[i])}, C: ${Math.round(sortedCompat[i])})`),
      datasets: [{
        label: `Score (${methodName})`,
        data: sortedScores,
        backgroundColor: 'rgba(54, 162, 235, 0.6)',
        borderColor: 'rgba(54, 162, 235, 1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      plugins: {
        title: {
          display: true,
          text: `Prediction Analysis: ${methodName}`
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              const index = context.dataIndex;
              const baseInfo = `Freq: ${Math.round(sortedFreq[index])}, Compat: ${Math.round(sortedCompat[index])}, Total: ${sortedScores[index]}`;
              
              if (extraData && extraData[numbers.indexOf(sortedNumbers[index])]) {
                const data = extraData[numbers.indexOf(sortedNumbers[index])];
                if (data.temperature) {
                  return `${baseInfo}, Trend: ${data.temperature} (${data.trend > 0 ? '+' : ''}${data.trend.toFixed(1)})`;
                } else if (data.weighted) {
                  return `${baseInfo}, Weighted: ${data.weighted.toFixed(1)}`;
                }
              }
              
              return baseInfo;
            }
          }
        }
      },
      scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } } }
    }
  });
}
</script>
</body>
</html>
