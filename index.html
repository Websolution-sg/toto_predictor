<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Singapore TOTO Predictor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font: 16px/1.5 Arial; padding: 20px; max-width: 600px; margin: auto; }
    select, button, input { font-size: 1em; margin: 0.5em 0; }
    canvas { max-width: 100%; }
  </style>
</head>
<body>
  <h1>Singapore TOTO Predictor</h1>
  <p id="recentResult">RECENT RESULT: Loading...</p>
  <p>By default, the previous lottery result is selected:</p>
  <div>
    <select id="base1"></select>
    <select id="base2"></select>
    <select id="base3"></select>
    <select id="base4"></select>
    <select id="base5"></select>
    <select id="base6"></select>
  </div>

  <div>
    <label>Additional Number:</label><br/>
    <select id="additional"></select>
  </div>

  <div>
    <label>Select draw range:</label><br/>
    <select id="drawRange">
      <option value="20">Last 20</option>
      <option value="50">Last 50</option>
      <option value="100">Last 100</option>
    </select>
  </div>

  <label><input type="checkbox" id="includeAdd"/> Include additional number</label><br/>
  <button onclick="predict()">Predict</button>

  <h2>Results</h2>
  <div id="results"></div>
  <canvas id="freqChart"></canvas>

<script>
let historical = [];
let chartInstance = null;

// Enhanced cache-busting with multiple parameters to ensure fresh CSV data
const cacheBuster = new Date().getTime();
const randomId = Math.random().toString(36).substring(7);
const csvUrl = `totoResult.csv?v=${cacheBuster}&r=${randomId}&nocache=${Date.now()}`;

console.log('ðŸ”„ Fetching CSV from:', csvUrl);
fetch(csvUrl, {
  cache: 'no-cache',
  headers: {
    'Cache-Control': 'no-cache, no-store, must-revalidate',
    'Pragma': 'no-cache',
    'Expires': '0'
  }
})
  .then(response => response.text())
  .then(text => {
    historical = text.trim().split('\n').map(line => line.split(',').map(Number));
    for (let i = 1; i <= 49; i++) {
      ['base1', 'base2', 'base3', 'base4', 'base5', 'base6', 'additional'].forEach(id => {
        const opt = document.createElement('option');
        opt.value = opt.textContent = i;
        document.getElementById(id).append(opt);
      });
    }
    const recent = historical[0];
    ['base1', 'base2', 'base3', 'base4', 'base5', 'base6'].forEach((id, idx) => {
      document.getElementById(id).value = recent[idx];
    });
    document.getElementById('additional').value = recent[6];
    document.getElementById('includeAdd').checked = false;
    const today = new Date();
    const dateStr = today.toLocaleDateString('en-SG', { day: '2-digit', month: '2-digit', year: 'numeric' });
    updateLatestResult(recent.slice(0, 6), recent[6], dateStr);
  })
  .catch(error => {
    alert("Failed to load historical data.");
    console.error(error);
  });

function updateLatestResult(winningNumbers, additionalNumber, drawDate = null) {
  const resultText = `${winningNumbers.join(',')}(${additionalNumber})`;
  const resultElement = document.getElementById('recentResult');
  if (resultElement) {
    resultElement.textContent = `RECENT RESULT: ${resultText}${drawDate ? ' - ' + drawDate : ''}`;
  }
}

function hasDuplicates(arr) {
  return new Set(arr).size !== arr.length;
}

function predict() {
  const bases = getSelectedBases();
  if (hasDuplicates(bases)) {
    alert("Duplicate base numbers selected. Please choose unique numbers.");
    return;
  }
  const hasHistoricalMatch = checkHistoricalAndMaybePredict();
  if (!hasHistoricalMatch) {
    runFrequencyCompatibilityPrediction();
  }
}

function getSelectedBases() {
  return ['base1', 'base2', 'base3', 'base4', 'base5', 'base6']
    .map(id => parseInt(document.getElementById(id).value))
    .sort((a, b) => a - b);
}

function arraysEqual(a, b) {
  return a.length === b.length && a.every((val, index) => val === b[index]);
}

function checkHistoricalAndMaybePredict() {
  const bases = getSelectedBases();
  const mostRecentDraw = historical[0].slice(0, 6).sort((a, b) => a - b);
  if (arraysEqual(bases, mostRecentDraw)) return false;
  for (let i = historical.length - 1; i > 0; i--) {
    const draw = historical[i].slice(0, 6).sort((a, b) => a - b);
    if (arraysEqual(draw, mostRecentDraw)) continue;
    if (arraysEqual(draw, bases)) {
      const prevDraw = historical[i - 1];
      calculateScoresAndDisplay(prevDraw.slice(0, 6), prevDraw[6]);
      return true;
    }
  }
  return false;
}

function calculateScoresAndDisplay(numbers, additional = null) {
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  const freq = Array(50).fill(0);
  const compat = Array(50).fill(0);
  draws.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => freq[n]++);
    numbers.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n]++);
      }
    });
  });
  const scores = numbers.map(n => freq[n] + compat[n]);
  displayPredictedNumbers(numbers, additional, scores, freq, compat);
}

function runFrequencyCompatibilityPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  const freq = Array(50).fill(0);
  const compat = Array(50).fill(0);
  draws.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => freq[n]++);
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n]++);
      }
    });
  });
  const suggestions = freq.map((count, n) => ({ n, count, compat: compat[n] }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => (b.compat + b.count) - (a.compat + a.count) || b.count - a.count || a.n - b.n)
    .slice(0, 6);
  const scores = suggestions.map(o => o.count + o.compat);
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat);
}

function displayPredictedNumbers(numbers, additional = null, scores, freq, compat) {
  const rs = document.getElementById('results');
  const sorted = numbers.map((n, i) => ({ n, score: scores[i], freq: freq[n], compat: compat[n] }))
    .sort((a, b) => a.n - b.n);
  const sortedNumbers = sorted.map(o => o.n);
  const sortedScores = sorted.map(o => o.score);
  const sortedFreq = sorted.map(o => o.freq);
  const sortedCompat = sorted.map(o => o.compat);
  rs.innerHTML = '<h3>Predicted Numbers:</h3>' + `<p>${sortedNumbers.join(', ')}</p>`;
  const ctx = document.getElementById('freqChart').getContext('2d');
  if (chartInstance) chartInstance.destroy();
  chartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: sortedNumbers.map((n, i) => `${n} (F: ${sortedFreq[i]}, C: ${sortedCompat[i]})`),
      datasets: [{
        label: 'Total Score',
        data: sortedScores,
        backgroundColor: 'rgba(54, 162, 235, 0.6)',
        borderColor: 'rgba(54, 162, 235, 1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      plugins: {
        tooltip: {
          callbacks: {
            label: function(context) {
              const index = context.dataIndex;
              return `Freq: ${sortedFreq[index]}, Compat: ${sortedCompat[index]}, Total: ${sortedScores[index]}`;
            }
          }
        }
      },
      scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } } }
    }
  });
}
</script>
</body>
</html>
