<!DOCTYPE html>
<html lang="en">
<head> 
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Singapore TOTO Predictor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font: 16px/1.5 Arial; padding: 20px; max-width: 600px; margin: auto; }
    select, button, input { font-size: 1em; margin: 0.5em 0; }
    canvas { max-width: 100%; }
    
    /* Navigation Styles */
    .nav-container {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 25px;
      text-align: center;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .nav-title {
      color: white;
      font-size: 24px;
      font-weight: bold;
      margin: 0 0 15px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .nav-links {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    .nav-link {
      background: rgba(255,255,255,0.9);
      color: #333;
      text-decoration: none;
      padding: 12px 24px;
      border-radius: 25px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .nav-link:hover {
      background: white;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .nav-link.active {
      background: #28a745;
      color: white;
    }
  </style>
</head>
<body>
  <!-- Navigation Section -->
  <div class="nav-container">
    <div class="nav-title">Singapore Pools Predictors</div>
    <div class="nav-links">
      <a href="./index.html" class="nav-link active" onclick="navigateToToto(event)">🎯 TOTO Predictor</a>
      <a href="./4d_predictor.html" class="nav-link" onclick="navigateTo4D(event)">🔢 4D Predictor</a>
    </div>
  </div>

  <script>
    function navigateToToto(event) {
      event.preventDefault();
      window.location.reload();
    }
    
    function navigateTo4D(event) {
      event.preventDefault();
      window.location.href = './4d_predictor.html';
    }
  </script>

  <h1>Singapore TOTO Predictor</h1>
  <p id="recentResult">RECENT RESULT: Loading...</p>
  <p>By default, the previous lottery result is selected:</p>
  <div>
    <select id="base1"></select>
    <select id="base2"></select>
    <select id="base3"></select>
    <select id="base4"></select>
    <select id="base5"></select>
    <select id="base6"></select>
  </div>

  <div>
    <label>Additional Number:</label><br/>
    <select id="additional"></select>
  </div>

  <div>
    <label>Select draw range:</label><br/>
    <select id="drawRange">
      <option value="20">Last 20</option>
      <option value="50">Last 50</option>
      <option value="100">Last 100</option>
    </select>
  </div>

  <div>
    <label>System Type:</label><br/>
    <select id="systemType">
      <option value="6">System 6 </option>
      <option value="7">System 7 </option>
    </select>
  </div>

  <label><input type="checkbox" id="includeAdd"/> Include additional number</label><br/>
  <label><input type="checkbox" id="showAnalytics" checked/> Show detailed analytics</label><br/>
  <button onclick="predict()">Predict</button>

  <h2>Results</h2>
  <div id="results"></div>
  <div id="analytics" style="margin-top: 20px;"></div>
  <canvas id="freqChart"></canvas>

<script>
let historical = [];
let chartInstance = null;

// Auto-refresh functionality for latest TOTO results
class TotoAutoRefreshManager {
  constructor() {
    this.refreshInterval = 5 * 60 * 1000; // 5 minutes
    this.lastUpdateTime = null;
    this.intervalId = null;
    this.isRefreshing = false;
    this.statusElement = null;
    this.init();
  }

  init() {
    this.createStatusIndicator();
    this.startAutoRefresh();
    this.checkForUpdates(); // Initial check
  }

  createStatusIndicator() {
    const resultElement = document.getElementById('recentResult');
    if (resultElement) {
      // Add refresh status indicator
      const statusHtml = `
        <div id="refresh-status" style="margin-top: 8px; font-size: 11px; color: #666;">
          <span id="refresh-indicator" style="display: inline-block; width: 8px; height: 8px; background: #28a745; border-radius: 50%; margin-right: 6px;"></span>
          <span id="refresh-text">Auto-refresh active</span>
          <span style="margin-left: 10px; font-size: 10px; color: #999;">Next check in <span id="countdown">5:00</span></span>
        </div>
      `;
      resultElement.insertAdjacentHTML('afterend', statusHtml);
      this.statusElement = document.getElementById('refresh-status');
      this.startCountdown();
    }
  }

  startAutoRefresh() {
    this.intervalId = setInterval(() => {
      this.checkForUpdates();
    }, this.refreshInterval);
    this.startCountdown();
  }

  startCountdown() {
    let seconds = this.refreshInterval / 1000;
    const countdown = document.getElementById('countdown');
    if (!countdown) return;
    countdown.textContent = `${Math.floor(seconds / 60)}:${('0' + (seconds % 60)).slice(-2)}`;
    clearInterval(this.countdownId);
    this.countdownId = setInterval(() => {
      seconds--;
      if (seconds < 0) seconds = this.refreshInterval / 1000;
      countdown.textContent = `${Math.floor(seconds / 60)}:${('0' + (seconds % 60)).slice(-2)}`;
    }, 1000);
  }

  async checkForUpdates() {
    if (this.isRefreshing) return;
    try {
      this.isRefreshing = true;
      this.updateStatus('checking', 'Checking for latest TOTO results...');
      const cacheBuster = Date.now();
      const csvUrl = `totoResult.csv?nocache=${cacheBuster}`;
      const response = await fetch(csvUrl, {
        cache: 'no-cache',
        headers: {
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache',
          'Expires': '0'
        }
      });
      if (!response.ok) throw new Error('Failed to fetch CSV');
      const text = await response.text();
      if (!text.trim()) throw new Error('CSV file is empty');
      historical = text.trim().split('\n').map(line => {
        const numbers = line.split(',').map(Number);
        if (numbers.length !== 7) return null;
        return numbers;
      }).filter(line => line !== null);
      if (historical.length === 0) throw new Error('No valid data found in CSV');
      this.updateDisplay(historical[0]);
      this.updateStatus('updated', 'Updated with latest TOTO results!');
      this.showUpdateNotification('New TOTO results available!', 'success');
    } catch (error) {
      console.error('TOTO CSV update error:', error);
      this.updateStatus('error', 'Update check failed');
      this.showUpdateNotification('Update check failed', 'error');
      // Fallback to sample data
      this.loadFallbackData();
    } finally {
      this.isRefreshing = false;
      setTimeout(() => {
        this.updateStatus('active', 'Auto-refresh active');
      }, 3000);
    }
  }

  updateDisplay(recent) {
    if (!recent) return;
    ['base1', 'base2', 'base3', 'base4', 'base5', 'base6'].forEach((id, idx) => {
      document.getElementById(id).value = recent[idx];
    });
    document.getElementById('additional').value = recent[6];
    document.getElementById('includeAdd').checked = false;
    // Try to get draw date from CSV (assume column 7 or last column if present)
    let drawDate = '';
    if (recent.length > 7 && recent[7]) {
      drawDate = recent[7];
    } else if (recent.length > 6 && typeof recent[6] === 'string' && /\d{4}/.test(recent[6])) {
      drawDate = recent[6];
    } else {
      drawDate = '';
    }
    updateLatestResult(recent.slice(0, 6), recent[6], drawDate);
  }

  updateStatus(type, text) {
    const indicator = document.getElementById('refresh-indicator');
    const statusText = document.getElementById('refresh-text');
    if (!indicator || !statusText) return;
    const colors = {
      'active': '#28a745',
      'checking': '#17a2b8',
      'updated': '#ffc107',
      'error': '#dc3545'
    };
    indicator.style.background = colors[type] || colors.active;
    statusText.textContent = text;
  }

  showUpdateNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 20px;
      border-radius: 6px;
      color: white;
      font-weight: 500;
      z-index: 10000;
      animation: slideIn 0.3s ease;
    `;
    const colors = {
      'success': '#28a745',
      'error': '#dc3545',
      'info': '#17a2b8',
      'warning': '#ffc107'
    };
    notification.style.background = colors[type] || colors.info;
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.remove();
    }, 3000);
  }

  loadFallbackData() {
    historical = [
      [4,13,22,36,38,46,12],
      [1,4,18,24,37,42,26],
      [22,25,29,31,34,43,11],
      [9,24,31,34,43,44,1],
      [2,15,28,39,42,44,5],
      [30,32,40,43,45,49,5],
      [7,19,20,21,22,29,37],
      [2,14,16,21,36,47,1],
      [9,11,24,32,39,49,26],
      [2,5,10,12,14,37,17]
    ];
    this.updateDisplay(historical[0]);
    // Ensure text color is black
    const resultElement = document.getElementById('recentResult');
    if (resultElement) {
      resultElement.style.color = '#000000';
    }
  }
}

window.addEventListener('DOMContentLoaded', () => {
  new TotoAutoRefreshManager();
});

function updateLatestResult(winningNumbers, additionalNumber, drawDate = null) {
  const resultText = `${winningNumbers.join(',')}(${additionalNumber})`;
  const resultElement = document.getElementById('recentResult');
  if (resultElement) {
    resultElement.textContent = `RECENT RESULT: ${resultText}${drawDate ? ' - ' + drawDate : ''}`;
  }
}

function hasDuplicates(arr) {
  return new Set(arr).size !== arr.length;
}

function predict() {
  const bases = getSelectedBases();
  if (hasDuplicates(bases)) {
    alert("Duplicate base numbers selected. Please choose unique numbers.");
    return;
  }
  
  // Check if we should use historical match first
  const hasHistoricalMatch = checkHistoricalAndMaybePredict();
  if (hasHistoricalMatch) return;
  
  // Always use Enhanced Analysis method (best performance)
  runEnhancedPrediction();
}

function getSelectedBases() {
  return ['base1', 'base2', 'base3', 'base4', 'base5', 'base6']
    .map(id => parseInt(document.getElementById(id).value))
    .sort((a, b) => a - b);
}

function arraysEqual(a, b) {
  return a.length === b.length && a.every((val, index) => val === b[index]);
}

function checkHistoricalAndMaybePredict() {
  const bases = getSelectedBases();
  const mostRecentDraw = historical[0].slice(0, 6).sort((a, b) => a - b);
  if (arraysEqual(bases, mostRecentDraw)) return false;
  for (let i = historical.length - 1; i > 0; i--) {
    const draw = historical[i].slice(0, 6).sort((a, b) => a - b);
    if (arraysEqual(draw, mostRecentDraw)) continue;
    if (arraysEqual(draw, bases)) {
      const prevDraw = historical[i - 1];
      calculateScoresAndDisplay(prevDraw.slice(0, 6), prevDraw[6]);
      return true;
    }
  }
  return false;
}

function calculateScoresAndDisplay(numbers, additional = null) {
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  const freq = Array(50).fill(0);
  const compat = Array(50).fill(0);
  draws.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => freq[n]++);
    numbers.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n]++);
      }
    });
  });
  const scores = numbers.map(n => freq[n] + compat[n]);
  displayPredictedNumbers(numbers, additional, scores, freq, compat, 'Historical Pattern Match');
}

function runFrequencyCompatibilityPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  const freq = Array(50).fill(0);
  const compat = Array(50).fill(0);
  draws.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => freq[n]++);
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n]++);
      }
    });
  });
  const suggestions = freq.map((count, n) => ({ n, count, compat: compat[n] }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => (b.compat + b.count) - (a.compat + a.count) || b.count - a.count || a.n - b.n)
    .slice(0, 6);
  const scores = suggestions.map(o => o.count + o.compat);
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat, 'Frequency + Compatibility Analysis');
}

// Enhanced Prediction - Combines multiple factors with weighted analysis
function runEnhancedPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  
  const freq = Array(50).fill(0);
  const compat = Array(50).fill(0);
  const weighted = Array(50).fill(0);
  
  draws.forEach((draw, index) => {
    const weight = Math.exp(-index * 0.03); // Recent draws weighted higher
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    
    pool.forEach(n => {
      freq[n]++;
      weighted[n] += weight;
    });
    
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n] += weight);
      }
    });
  });
  
  const suggestions = freq.map((count, n) => ({ 
    n, 
    freq: count,
    compat: compat[n],
    weighted: weighted[n],
    score: count + compat[n] + weighted[n] * 0.5
  }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => b.score - a.score || a.n - b.n)
    .slice(0, 6);
    
  const scores = suggestions.map(o => o.score);
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat, 'Enhanced Analysis (Freq + Compat + Weighted)');
}

// Weighted Recent Prediction - Recent draws count more
function runWeightedPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  
  const weighted = Array(50).fill(0);
  const compat = Array(50).fill(0);
  
  draws.forEach((draw, index) => {
    const weight = 1 / (index + 1); // Linear decay
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    
    pool.forEach(n => weighted[n] += weight);
    
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n] += weight);
      }
    });
  });
  
  const suggestions = weighted.map((weight, n) => ({ 
    n, 
    weight, 
    compat: compat[n],
    score: weight + compat[n]
  }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => b.score - a.score || a.n - b.n)
    .slice(0, 6);
    
  const scores = suggestions.map(o => o.score);
  const freq = suggestions.map(o => o.weight);
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat, 'Weighted Recent Analysis');
}

// Hot/Cold Analysis - Trending numbers
function runHotColdPrediction() {
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const recentDraws = historical.slice(0, Math.floor(range / 2));
  const olderDraws = historical.slice(Math.floor(range / 2), range);
  
  const recentFreq = Array(50).fill(0);
  const olderFreq = Array(50).fill(0);
  
  recentDraws.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => recentFreq[n]++);
  });
  
  olderDraws.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => olderFreq[n]++);
  });
  
  const suggestions = recentFreq.map((recent, n) => ({
    n,
    recent,
    older: olderFreq[n],
    trend: recent - olderFreq[n],
    score: recent + Math.max(0, recent - olderFreq[n]) * 0.5
  }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => b.score - a.score || a.n - b.n)
    .slice(0, 6);
    
  const scores = suggestions.map(o => o.score);
  const freq = suggestions.map(o => o.recent);
  const compat = suggestions.map(o => o.trend);
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat, 'Hot/Cold Trend Analysis');
}

// ENHANCEMENT 1: Enhanced Combined Analysis
function runEnhancedPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  
  const freq = Array(50).fill(0);
  const compat = Array(50).fill(0);
  const hotness = Array(50).fill(0);
  const weighted = Array(50).fill(0);
  
  draws.forEach((draw, index) => {
    const weight = Math.exp(-index * 0.05); // Recent draws weighted higher
    const recentBonus = index < range * 0.3 ? 2 : 1; // Extra bonus for very recent
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    
    pool.forEach(n => {
      freq[n]++;
      weighted[n] += weight;
      hotness[n] += recentBonus;
    });
    
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => {
          compat[n]++;
        });
      }
    });
  });
  
  const suggestions = freq.map((count, n) => ({ 
    n, 
    freq: count, 
    compat: compat[n],
    weighted: weighted[n],
    hotness: hotness[n],
    score: count + compat[n] + weighted[n] * 0.5 + hotness[n] * 0.3
  }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => b.score - a.score || a.n - b.n);
    
  // Get system type (6 or 7 numbers)
  const systemType = parseInt(document.getElementById('systemType').value);
  const finalSuggestions = suggestions.slice(0, systemType);
    
  const scores = finalSuggestions.map(o => Math.round(o.score));
  displayPredictedNumbers(finalSuggestions.map(o => o.n), null, scores, freq, compat, '', finalSuggestions);
}

// ENHANCEMENT 2: Weighted Recent Analysis
function runWeightedPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  
  const weighted = Array(50).fill(0);
  const compat = Array(50).fill(0);
  
  draws.forEach((draw, index) => {
    const weight = Math.exp(-index * 0.1); // Exponential decay for older draws
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    
    pool.forEach(n => weighted[n] += weight);
    
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n] += weight);
      }
    });
  });
  
  const suggestions = weighted.map((weight, n) => ({ 
    n, 
    weight: weight, 
    compat: compat[n],
    score: weight + compat[n] * 1.5
  }))
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => b.score - a.score || a.n - b.n)
    .slice(0, 6);
    
  const scores = suggestions.map(o => Math.round(o.score * 10) / 10);
  const freq = weighted; // Use weighted as freq for display
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat, 'Weighted Recent Draw Analysis');
}

// ENHANCEMENT 3: Hot/Cold Number Analysis
function runHotColdPrediction() {
  const bases = getSelectedBases();
  const range = parseInt(document.getElementById('drawRange').value);
  const includeAdd = document.getElementById('includeAdd').checked;
  const draws = historical.slice(0, range);
  
  const recentRange = Math.floor(range * 0.3);
  const recent = draws.slice(0, recentRange);
  const older = draws.slice(recentRange);
  
  const recentFreq = Array(50).fill(0);
  const olderFreq = Array(50).fill(0);
  const compat = Array(50).fill(0);
  
  recent.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => recentFreq[n]++);
  });
  
  older.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    pool.forEach(n => olderFreq[n]++);
  });
  
  draws.forEach(draw => {
    const pool = includeAdd && draw.length >= 7 ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
    bases.forEach(b => {
      if (pool.includes(b)) {
        pool.filter(n => n !== b).forEach(n => compat[n]++);
      }
    });
  });
  
  const suggestions = recentFreq.map((recent, n) => {
    const older = olderFreq[n];
    const trend = recent - (older * (recentRange / (range - recentRange))); // Normalize for different periods
    const temperature = trend > 0 ? 'hot' : trend < 0 ? 'cold' : 'neutral';
    const hotBonus = trend > 0 ? trend * 2 : 0;
    
    return { 
      n, 
      recent: recent,
      trend: trend,
      temperature: temperature,
      compat: compat[n],
      score: recent + compat[n] + hotBonus
    };
  })
    .filter(o => o.n >= 1 && o.n <= 49)
    .sort((a, b) => b.score - a.score || a.n - b.n)
    .slice(0, 6);
    
  const scores = suggestions.map(o => Math.round(o.score));
  displayPredictedNumbers(suggestions.map(o => o.n), null, scores, recentFreq, compat, 'Hot/Cold Number Analysis', suggestions);
}

function displayPredictedNumbers(numbers, additional = null, scores, freq, compat, methodName = 'Analysis', extraData = null) {
  const rs = document.getElementById('results');
  const analytics = document.getElementById('analytics');
  const showAnalytics = document.getElementById('showAnalytics').checked;
  const systemType = document.getElementById('systemType').value;
  
  const sorted = numbers.map((n, i) => ({ n, score: scores[i], freq: freq[n], compat: compat[n] }))
    .sort((a, b) => a.n - b.n);
  const sortedNumbers = sorted.map(o => o.n);
  const sortedScores = sorted.map(o => o.score);
  const sortedFreq = sorted.map(o => o.freq);
  const sortedCompat = sorted.map(o => o.compat);
  
  // Main results display with system type info
  const systemInfo = '';

  rs.innerHTML = `
    <h3>Predicted Numbers:</h3>
    <p style="font-size: 1.2em; font-weight: bold; color: #2c5aa0;">${sortedNumbers.join(', ')}</p>
    <p style="margin-top: 10px; font-size: 0.95em;">${systemInfo}</p>
    ${additional ? `<p><strong>Additional Number:</strong> ${additional}</p>` : ''}
  `;
  
  // Analytics display
  if (showAnalytics) {
    let analyticsHtml = `
      <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-top: 10px;">
        <h4>Detailed Analytics (${methodName})</h4>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px;">
    `;
    
    sortedNumbers.forEach((num, i) => {
      let extraInfo = '';
      if (extraData && extraData[numbers.indexOf(num)]) {
        const data = extraData[numbers.indexOf(num)];
        if (data.temperature) {
          extraInfo = `<br>🌡️ ${data.temperature.toUpperCase()} (${data.trend > 0 ? '+' : ''}${data.trend.toFixed(1)})`;
        } else if (data.weighted) {
          extraInfo = `<br>⚖️ Weighted: ${data.weighted.toFixed(1)}`;
        }
      }
      
      analyticsHtml += `
        <div style="background: white; padding: 10px; border-radius: 5px; border-left: 4px solid #2c5aa0;">
          <strong>Number ${num}</strong><br>
          📈 Score: ${sortedScores[i]}<br>
          🔢 Frequency: ${Math.round(sortedFreq[i] * 10) / 10}<br>
          🤝 Compatibility: ${Math.round(sortedCompat[i] * 10) / 10}${extraInfo}
        </div>
      `;
    });
    
    analyticsHtml += `</div>`;
    
    // Add method explanation
    const explanations = {
      'Frequency + Compatibility Analysis': 'Original algorithm analyzing how often numbers appear and their compatibility with selected numbers.',
      'Weighted Recent Draw Analysis': 'Gives more importance to recent draws using exponential decay weighting.',
      'Hot/Cold Number Analysis': 'Identifies trending numbers by comparing recent vs historical frequency.',
    };
    
    if (explanations[methodName]) {
      analyticsHtml += `
        <div style="background: #e8f4f8; padding: 10px; border-radius: 5px; margin-top: 10px;">
          <strong>📋 Method Explanation:</strong><br>
          ${explanations[methodName]}
        </div>
      `;
    }
    
    // Add prediction confidence
    const avgScore = sortedScores.reduce((a, b) => a + b, 0) / sortedScores.length;
    const maxPossibleScore = Math.max(...scores);
    const confidence = Math.round((avgScore / maxPossibleScore) * 100);
    
    analyticsHtml += `
      <div style="background: #f0f8e8; padding: 10px; border-radius: 5px; margin-top: 10px;">
        <strong>Prediction Confidence:</strong> ${confidence}%<br>
        <strong>Average Score:</strong> ${avgScore.toFixed(1)}<br>
        <strong>📈 Score Range:</strong> ${Math.min(...sortedScores)} - ${Math.max(...sortedScores)}
      </div>
    `;
    
    // Add System 7 benefit explanation
    if (systemType === '7') {
      analyticsHtml += `
        <div style="background: #e8f8e8; padding: 10px; border-radius: 5px; margin-top: 10px; border-left: 4px solid #28a745;">
          <strong>System 7 Advantage:</strong><br>
          By selecting 7 numbers instead of 6, you significantly increase your winning chances:<br>
          • More combinations covered (7 vs 6)<br>
          • Higher probability of matching winning numbers<br>
        </div>
      `;
    }
    
    analyticsHtml += `</div>`;
    analytics.innerHTML = analyticsHtml;
  } else {
    analytics.innerHTML = '';
  }
  
  // Chart display
  const ctx = document.getElementById('freqChart').getContext('2d');
  if (chartInstance) chartInstance.destroy();
  chartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: sortedNumbers.map((n, i) => `${n} (F: ${Math.round(sortedFreq[i])}, C: ${Math.round(sortedCompat[i])})`),
      datasets: [{
        label: `Score (${methodName})`,
        data: sortedScores,
        backgroundColor: 'rgba(54, 162, 235, 0.6)',
        borderColor: 'rgba(54, 162, 235, 1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      plugins: {
        title: {
          display: true,
          text: `Prediction Analysis: ${methodName}`
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              const index = context.dataIndex;
              const baseInfo = `Freq: ${Math.round(sortedFreq[index])}, Compat: ${Math.round(sortedCompat[index])}, Total: ${sortedScores[index]}`;
              
              if (extraData && extraData[numbers.indexOf(sortedNumbers[index])]) {
                const data = extraData[numbers.indexOf(sortedNumbers[index])];
                if (data.temperature) {
                  return `${baseInfo}, Trend: ${data.temperature} (${data.trend > 0 ? '+' : ''}${data.trend.toFixed(1)})`;
                } else if (data.weighted) {
                  return `${baseInfo}, Weighted: ${data.weighted.toFixed(1)}`;
                }
              }
              
              return baseInfo;
            }
          }
        }
      },
      scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } } }
    }
  });
}
</script>
</body>
</html>
