<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Singapore TOTO Predictor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font: 16px/1.5 Arial; padding: 20px; max-width: 600px; margin: auto; }
    select, button, input { font-size: 1em; margin: 0.5em 0; }
    canvas { max-width: 100%; }
    .loading { opacity: 0.5; }
    .error { color: red; }
    .success { color: green; }
  </style>
</head>
<body>
  <h1>Singapore TOTO Predictor</h1>
  <p id="recentResult">RECENT RESULT: Loading...</p>
  <p>By default, the previous lottery result is selected:</p>
  <div>
    <select id="base1"></select>
    <select id="base2"></select>
    <select id="base3"></select>
    <select id="base4"></select>
    <select id="base5"></select>
    <select id="base6"></select>
  </div>
 
  <div>
    <label>Additional Number:</label><br/>
    <select id="additional"></select>
  </div>
  
  <div>
    <label>Select draw range:</label><br/>
    <select id="drawRange">
      <option value="20">Last 20</option>
      <option value="50">Last 50</option>
      <option value="100">Last 100</option>
    </select>
  </div>
  
  <label>
   <input type="checkbox" id="includeAdd"/> Include additional number

  </label><br/>

  <button onclick="predict()">Predict</button>

  <h2>Results</h2>
  <div id="results"></div>
  <canvas id="freqChart"></canvas>

<script>
let historical = [];

fetch('totoResult.csv')
  .then(response => response.text())
  .then(text => {
    historical = text
      .trim()
      .split('\n')
      .map(line => line.split(',').map(Number));

    // Populate selects
    for (let i = 1; i <= 49; i++) {
      ['base1', 'base2', 'base3', 'base4', 'base5', 'base6', 'additional'].forEach(id => {
        const opt = document.createElement('option');
        opt.value = opt.textContent = i;
        document.getElementById(id).append(opt);
      });
    }

    // Auto-select most recent result
    const recent = historical[0];
    ['base1', 'base2', 'base3', 'base4', 'base5', 'base6'].forEach((id, idx) => {
      document.getElementById(id).value = recent[idx];
    });
    document.getElementById('additional').value = recent[6];
    document.getElementById('includeAdd').checked = false;
    
    // Display the current recent result from CSV with current date
    const today = new Date();
    const dateStr = today.toLocaleDateString('en-SG', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
    updateLatestResult(recent.slice(0, 6), recent[6], 'success', dateStr);
  });
      const refreshButton = document.querySelector('button[onclick="fetchLatestTotoResults()"]');
      
      try {
        // Show loading state
        resultElement.className = 'loading';
        resultElement.textContent = 'RECENT RESULT: Fetching latest results...';
        refreshButton.disabled = true;
        refreshButton.textContent = 'Fetching...';
        
        console.log('Fetching latest TOTO results...');
        
        // Fetch from Singapore Pools website
        const response = await fetch('https://www.singaporepools.com.sg/en/product/Pages/toto_results.aspx', {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const text = await response.text();
        
        // Create a temporary element to parse the HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, 'text/html');
        
        // Find the latest draw info
        const drawDateElement = doc.querySelector('.table-responsive .table tbody tr:first-child td:first-child');
        const numbersElement = doc.querySelector('.table-responsive .table tbody tr:first-child td:nth-child(2)');
        const additionalElement = doc.querySelector('.table-responsive .table tbody tr:first-child td:nth-child(3)');
        
        if (!drawDateElement || !numbersElement || !additionalElement) {
            throw new Error('Could not find draw information on the page');
        }
        
        // Parse the draw date (format: DD/MM/YYYY)
        const drawDate = drawDateElement.textContent.trim();
        
        // Parse winning numbers and additional number
        const winningNumbers = numbersElement.textContent.trim()
            .split(' ')
            .map(n => parseInt(n.trim()))
            .filter(n => !isNaN(n))
            .sort((a, b) => a - b);
            
        const additionalNumber = parseInt(additionalElement.textContent.trim());
          
          // Check if this is newer than our current data
          const currentLatest = historical[0];
          const newResult = [...winningNumbers, additionalNumber];
          
          // Store the draw date with the result
          newResult.drawDate = drawDate;
        
        // Only update if the result is different from what we have
        if (!arraysEqual(newResult, currentLatest)) {
          // Update the page display
          updateLatestResult(winningNumbers, additionalNumber);
          
          // Update the historical data array
          historical.unshift(newResult);
          
          // Auto-select the new result
          ['base1', 'base2', 'base3', 'base4', 'base5', 'base6'].forEach((id, idx) => {
            document.getElementById(id).value = winningNumbers[idx];
          });
          document.getElementById('additional').value = additionalNumber;
          
          console.log('Latest TOTO results updated successfully!');
        } else {
          console.log('Current data is already up to date.');
        }
        
      } catch (error) {
        console.error('Error fetching results:', error);
        const recent = historical[0];
        updateLatestResult(
          recent.slice(0, 6),
          recent[6],
          'error'
        );
      } finally {
        refreshButton.disabled = false;
        refreshButton.textContent = 'Refresh Latest Results';
      }
    }
    
    // Alternative function to manually update results
    function manuallyUpdateResults() {
      const numbers = prompt('Enter the 6 winning numbers separated by commas (e.g., 7,19,20,21,22,29):');
      const additional = prompt('Enter the additional number:');
      
      if (numbers && additional) {
        try {
          const winningNumbers = numbers.split(',').map(n => parseInt(n.trim()));
          const additionalNumber = parseInt(additional.trim());
          
          if (winningNumbers.length !== 6 || winningNumbers.some(n => isNaN(n) || n < 1 || n > 49)) {
            throw new Error('Invalid winning numbers');
          }
          
          if (isNaN(additionalNumber) || additionalNumber < 1 || additionalNumber > 49) {
            throw new Error('Invalid additional number');
          }
          
          updateLatestResult(winningNumbers, additionalNumber);
          
          // Update the historical data array
          const newResult = [...winningNumbers, additionalNumber];
          historical.unshift(newResult);
          
          // Auto-select the new result
          ['base1', 'base2', 'base3', 'base4', 'base5', 'base6'].forEach((id, idx) => {
            document.getElementById(id).value = winningNumbers[idx];
          });
          document.getElementById('additional').value = additionalNumber;
          
          alert('Results updated successfully!');
          
        } catch (error) {
          alert('Error: ' + error.message);
        }
      }
    }
    
    // Function to update the display of latest results
    function updateLatestResult(winningNumbers, additionalNumber, status = 'success', drawDate = null) {
      const resultElement = document.getElementById('recentResult');
      if (resultElement) {
        const timestamp = new Date().toLocaleString();
        const resultText = `${winningNumbers.join(', ')} + ${additionalNumber}`;
        resultElement.className = status;
        resultElement.innerHTML = `RECENT RESULT (${timestamp}): ${resultText}`;
      }
    }
    
    let chartInstance = null;

    function predict() {
      const hasHistoricalMatch = checkHistoricalAndMaybePredict();
      if (!hasHistoricalMatch) {
        runFrequencyCompatibilityPrediction();
      }
    }

function checkHistoricalAndMaybePredict() {
  const bases = getSelectedBases().sort((a, b) => a - b);
  const mostRecentDraw = historical[0].slice(0, 6).sort((a, b) => a - b);

  // ✅ Skip historical prediction entirely if base = most recent draw
  if (arraysEqual(bases, mostRecentDraw)) {
    return false;
  }

  for (let i = historical.length - 1; i > 0; i--) {
    const draw = historical[i].slice(0, 6).sort((a, b) => a - b);

    // This only prevents matching the most recent draw as a historical case
    if (arraysEqual(draw, mostRecentDraw)) {
      continue;
    }

    if (arraysEqual(draw, bases)) {
      const prevDraw = historical[i - 1];
      calculateScoresAndDisplay(prevDraw.slice(0, 6), prevDraw[6]);
      return true;
    }
  }

  return false;
}

    function getSelectedBases() {
      return ['base1', 'base2', 'base3', 'base4', 'base5', 'base6']
        .map(id => parseInt(document.getElementById(id).value))
        .sort((a, b) => a - b);
    }

    function arraysEqual(a, b) {
      return a.length === b.length && a.every((val, index) => val === b[index]);
    }

    function calculateScoresAndDisplay(numbers, additional = null) {
      const bases = numbers.slice();
      const range = parseInt(document.getElementById('drawRange').value);
      const includeAdd = document.getElementById('includeAdd').checked;
      const draws = historical.slice(0, range);
      const freq = Array(50).fill(0);
      const compat = Array(50).fill(0);

      draws.forEach(draw => {
        const pool = includeAdd ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
        pool.forEach(n => freq[n]++);
        bases.forEach(b => {
          if (pool.includes(b)) {
            pool.filter(n => n !== b).forEach(n => compat[n]++);
          }
        });
      });

      const scores = numbers.map(n => freq[n] + compat[n]);
      console.log('Sanity Check - Predicted Numbers:');
      numbers.forEach((n, i) => {
        console.log(`Number ${n} -> Frequency: ${freq[n]}, Compatibility: ${compat[n]}, Total Score: ${scores[i]}`);
      });
      displayPredictedNumbers(numbers, additional, scores, freq, compat);
    }

    function runFrequencyCompatibilityPrediction() {
      const bases = getSelectedBases();
      const range = parseInt(document.getElementById('drawRange').value);
      const includeAdd = document.getElementById('includeAdd').checked;
      const draws = historical.slice(0, range);
      const freq = Array(50).fill(0);
      const compat = Array(50).fill(0);

      draws.forEach(draw => {
        const pool = includeAdd ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
        pool.forEach(n => freq[n]++);
        bases.forEach(b => {
          if (pool.includes(b)) {
            pool.filter(n => n !== b).forEach(n => compat[n]++);
          }
        });
      });

      const suggestions = freq
        .map((count, n) => ({ n, count, compat: compat[n] }))
        .filter(o => o.n)
        .sort((a, b) => (b.compat + b.count) - (a.compat + a.count) || b.count - a.count || a.n - b.n)
        .slice(0, 6);

      const scores = suggestions.map(o => o.count + o.compat);
      console.log('Sanity Check - Suggestions:');
      suggestions.forEach((o, i) => {
        console.log(`Number ${o.n} -> Frequency: ${o.count}, Compatibility: ${o.compat}, Total Score: ${scores[i]}`);
      });
      displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat);
    }

    function displayPredictedNumbers(numbers, additional = null, scores, freq, compat) {
      const rs = document.getElementById('results');
      // Sort numbers, scores, freq, compat for both display and chart
     const sorted = numbers
     .map((n, i) => ({
      n,
      score: scores[i],
      freq: freq[n],
      compat: compat[n]
  }))
  .sort((a, b) => a.n - b.n);  // ✅ ASCENDING ORDER by number
      const sortedNumbers = sorted.map(o => o.n);
      const sortedScores = sorted.map(o => o.score);
      const sortedFreq = sorted.map(o => o.freq);
      const sortedCompat = sorted.map(o => o.compat);
      rs.innerHTML = '<h3>Predicted Numbers:</h3>' +
        `<p>${sortedNumbers.join(', ')}</p>`;

      const ctx = document.getElementById('freqChart').getContext('2d');
      if (chartInstance) {
        chartInstance.destroy();
      }
      chartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: sortedNumbers.map((n, i) => `${n}\n(freq: ${sortedFreq[i]}, compat: ${sortedCompat[i]})`),
          datasets: [{
            label: 'Total Score',
            data: sortedScores,
            backgroundColor: 'rgba(54, 162, 235, 0.6)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  const index = context.dataIndex;
                  return `Freq: ${sortedFreq[index]}, Compat: ${sortedCompat[index]}, Total: ${sortedScores[index]}`;
                }
              }
            }
          },
          scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } } }
        }
      });
    }
  </script>
</body>
</html>