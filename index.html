<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Singapore TOTO Predictor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font: 16px/1.5 Arial; padding: 20px; max-width: 600px; margin: auto; }
    select, button, input { font-size: 1em; margin: 0.5em 0; }
    canvas { max-width: 100%; }
  </style>
</head>
<body>
  <h1>Singapore TOTO Predictor</h1>
  <p id="recentResult">RECENT RESULT: Loading...</p>
  <p>By default, the previous lottery result is selected:</p>
  <div>
    <select id="base1"></select>
    <select id="base2"></select>
    <select id="base3"></select>
    <select id="base4"></select>
    <select id="base5"></select>
    <select id="base6"></select>
  </div>
 
  <div>
    <label>Additional Number:</label><br/>
    <select id="additional"></select>
  </div>
  
  <div>
    <label>Select draw range:</label><br/>
    <select id="drawRange">
      <option value="20">Last 20</option>
      <option value="50">Last 50</option>
      <option value="100">Last 100</option>
    </select>
  </div>
  
  <label>
   <input type="checkbox" id="includeAdd"/> Include additional number

  </label><br/>

  <button onclick="predict()">Predict</button>
  <button onclick="fetchLatestTotoResults()" style="background-color: #28a745; color: white; margin-left: 10px;">Refresh Latest Results</button>

  <h2>Results</h2>
  <div id="results"></div>
  <canvas id="freqChart"></canvas>

<script>
let historical = [];

fetch('totoResult.csv')
  .then(response => response.text())
  .then(text => {
    historical = text
      .trim()
      .split('\n')
      .map(line => line.split(',').map(Number));

    // Populate selects
    for (let i = 1; i <= 49; i++) {
      ['base1', 'base2', 'base3', 'base4', 'base5', 'base6', 'additional'].forEach(id => {
        const opt = document.createElement('option');
        opt.value = opt.textContent = i;
        document.getElementById(id).append(opt);
      })
    }


    // Auto-select most recent result
    const recent = historical[0];
    ['base1', 'base2', 'base3', 'base4', 'base5', 'base6'].forEach((id, idx) => {
      document.getElementById(id).value = recent[idx];
    });
    document.getElementById('additional').value = recent[6];
    document.getElementById('includeAdd').checked = false;
    
    // Display the current recent result from CSV
    updateLatestResult(recent.slice(0, 6), recent[6]);
    
    // Automatically fetch latest TOTO results on page load
    fetchLatestTotoResults();
  });
    
    // Function to fetch latest TOTO results from Singapore Pools
    async function fetchLatestTotoResults() {
      const resultElement = document.getElementById('recentResult');
      const refreshButton = document.querySelector('button[onclick="fetchLatestTotoResults()"]');
      
      try {
        // Show loading state
        if (resultElement) {
          resultElement.textContent = 'RECENT RESULT: Fetching latest results...';
        }
        if (refreshButton) {
          refreshButton.textContent = 'Fetching...';
          refreshButton.disabled = true;
        }
        
        console.log('Fetching latest TOTO results...');
        
        // First try to fetch directly from Singapore Pools
        let fetchedResults = await fetchFromSingaporePools();
        
        if (!fetchedResults) {
          // Fallback: Check if GitHub Action has updated the CSV
          console.log('Direct fetch failed, checking CSV for updates...');
          fetchedResults = await checkCSVForUpdates();
        }
        
        if (fetchedResults) {
          const { winningNumbers, additionalNumber } = fetchedResults;
          
          // Check if this is newer than our current data
          const currentLatest = historical[0];
          const newResult = [...winningNumbers, additionalNumber];
          
          if (!arraysEqual(newResult, currentLatest)) {
            // Update historical data
            historical.unshift(newResult);
            
            // Update the page display
            updateLatestResult(winningNumbers, additionalNumber);
            
            // Auto-select the new result
            ['base1', 'base2', 'base3', 'base4', 'base5', 'base6'].forEach((id, idx) => {
              document.getElementById(id).value = winningNumbers[idx];
            });
            document.getElementById('additional').value = additionalNumber;
            
            console.log('Latest TOTO results updated successfully!');
            
            // Show success message briefly
            if (refreshButton && refreshButton.textContent === 'Fetching...') {
              refreshButton.textContent = 'Updated!';
              setTimeout(() => {
                refreshButton.textContent = 'Refresh Latest Results';
              }, 2000);
            }
          } else {
            console.log('Current data is already up to date.');
            if (refreshButton && refreshButton.textContent === 'Fetching...') {
              refreshButton.textContent = 'Already Up to Date';
              setTimeout(() => {
                refreshButton.textContent = 'Refresh Latest Results';
              }, 2000);
            }
          }
        } else {
          // No new results found, restore original display
          const recent = historical[0];
          updateLatestResult(recent.slice(0, 6), recent[6]);
        }
        
      } catch (error) {
        console.error('Error fetching TOTO results:', error);
        console.log('Using existing data from CSV file.');
        
        // Restore original display on error
        const recent = historical[0];
        updateLatestResult(recent.slice(0, 6), recent[6]);
      } finally {
        // Reset button state
        if (refreshButton) {
          refreshButton.disabled = false;
          if (refreshButton.textContent === 'Fetching...') {
            refreshButton.textContent = 'Refresh Latest Results';
          }
        }
      }
    }
    
    // Function to fetch directly from Singapore Pools
    async function fetchFromSingaporePools() {
      try {
        // Try multiple endpoints and methods
        const endpoints = [
          'https://www.singaporepools.com.sg/api/toto/latest',
          'https://www.singaporepools.com.sg/DataFileArchive/Lottery/Output/toto_results_today.xml',
          'https://api.singaporepools.com.sg/toto/latest'
        ];
        
        for (const endpoint of endpoints) {
          try {
            console.log('Trying endpoint:', endpoint);
            
            const response = await fetch(endpoint, {
              method: 'GET',
              headers: {
                'Accept': 'application/json, application/xml, text/xml, */*',
                'Content-Type': 'application/json'
              },
              mode: 'cors'
            });
            
            if (!response.ok) {
              console.log(`Endpoint ${endpoint} failed with status: ${response.status}`);
              continue;
            }
            
            const contentType = response.headers.get('content-type');
            let data;
            
            if (contentType && contentType.includes('xml')) {
              const xmlText = await response.text();
              data = parseXMLResults(xmlText);
            } else {
              data = await response.json();
            }
            
            const results = extractTotoNumbers(data);
            if (results) {
              console.log('Successfully fetched from:', endpoint);
              return results;
            }
            
          } catch (endpointError) {
            console.log(`Endpoint ${endpoint} error:`, endpointError.message);
            continue;
          }
        }
        
        // Try web scraping as fallback
        return await scrapeFromWebsite();
        
      } catch (error) {
        console.log('Direct fetch from Singapore Pools failed:', error.message);
        return null;
      }
    }
    
    // Function to parse XML results
    function parseXMLResults(xmlText) {
      try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
        
        // Try different XML structures
        const numbers = [];
        
        // Method 1: Look for number elements
        const numberElements = xmlDoc.getElementsByTagName('number');
        for (let i = 0; i < Math.min(7, numberElements.length); i++) {
          numbers.push(parseInt(numberElements[i].textContent));
        }
        
        // Method 2: Look for draw results
        if (numbers.length < 7) {
          const drawElements = xmlDoc.getElementsByTagName('draw');
          if (drawElements.length > 0) {
            const drawText = drawElements[0].textContent;
            const extractedNumbers = drawText.match(/\d+/g);
            if (extractedNumbers && extractedNumbers.length >= 7) {
              return {
                winningNumbers: extractedNumbers.slice(0, 6).map(n => parseInt(n)),
                additionalNumber: parseInt(extractedNumbers[6])
              };
            }
          }
        }
        
        if (numbers.length >= 7) {
          return {
            winningNumbers: numbers.slice(0, 6),
            additionalNumber: numbers[6]
          };
        }
        
        return null;
      } catch (error) {
        console.log('XML parsing failed:', error);
        return null;
      }
    }
    
    // Function to extract TOTO numbers from API response
    function extractTotoNumbers(data) {
      try {
        let winningNumbers, additionalNumber;
        
        // Try different response formats
        if (data.results && data.results[0]) {
          const result = data.results[0];
          winningNumbers = result.winningNumbers || result.numbers || result.draw;
          additionalNumber = result.additionalNumber || result.additional || result.bonus;
        } else if (data.winningNumbers || data.numbers) {
          winningNumbers = data.winningNumbers || data.numbers;
          additionalNumber = data.additionalNumber || data.additional || data.bonus;
        } else if (data.draw) {
          winningNumbers = data.draw.slice(0, 6);
          additionalNumber = data.draw[6];
        } else if (Array.isArray(data) && data.length >= 7) {
          winningNumbers = data.slice(0, 6);
          additionalNumber = data[6];
        }
        
        // Validate the numbers
        if (winningNumbers && Array.isArray(winningNumbers) && winningNumbers.length === 6 && 
            additionalNumber && !isNaN(additionalNumber)) {
          
          const validNumbers = winningNumbers.every(n => !isNaN(n) && n >= 1 && n <= 49);
          const validAdditional = additionalNumber >= 1 && additionalNumber <= 49;
          
          if (validNumbers && validAdditional) {
            return { winningNumbers: winningNumbers.map(n => parseInt(n)), additionalNumber: parseInt(additionalNumber) };
          }
        }
        
        return null;
      } catch (error) {
        console.log('Number extraction failed:', error);
        return null;
      }
    }
    
    // Function to scrape from website (CORS proxy might be needed)
    async function scrapeFromWebsite() {
      try {
        // This might not work due to CORS, but worth trying
        const proxyUrls = [
          'https://api.allorigins.win/raw?url=',
          'https://corsproxy.io/?',
          'https://api.codetabs.com/v1/proxy?quest='
        ];
        
        const targetUrl = 'https://www.singaporepools.com.sg/en/product/sr/Pages/toto_results.aspx';
        
        for (const proxy of proxyUrls) {
          try {
            const response = await fetch(proxy + encodeURIComponent(targetUrl));
            const html = await response.text();
            
            // Look for number patterns in the HTML
            const numberMatches = html.match(/\b([1-9]|[1-4][0-9])\b/g);
            if (numberMatches && numberMatches.length >= 7) {
              const numbers = numberMatches.slice(0, 7).map(n => parseInt(n));
              if (numbers.every(n => n >= 1 && n <= 49)) {
                return {
                  winningNumbers: numbers.slice(0, 6),
                  additionalNumber: numbers[6]
                };
              }
            }
          } catch (proxyError) {
            console.log('Proxy attempt failed:', proxyError.message);
            continue;
          }
        }
        
        return null;
      } catch (error) {
        console.log('Web scraping failed:', error);
        return null;
      }
    }
    
    // Function to check CSV for updates (fallback)
    async function checkCSVForUpdates() {
      try {
        const response = await fetch('totoResult.csv?' + Date.now()); // Cache busting
        const text = await response.text();
        const newHistorical = text
          .trim()
          .split('\n')
          .map(line => line.split(',').map(Number));
        
        // Check if we have new data
        const currentLatest = historical[0];
        const fetchedLatest = newHistorical[0];
        
        if (!arraysEqual(fetchedLatest, currentLatest)) {
          // Update historical data
          historical = newHistorical;
          
          return {
            winningNumbers: fetchedLatest.slice(0, 6),
            additionalNumber: fetchedLatest[6]
          };
        }
        
        return null;
      } catch (error) {
        console.log('CSV check failed:', error);
        return null;
      }
    }
    
    // Alternative function to manually update results
    function manuallyUpdateResults() {
      const numbers = prompt('Enter the 6 winning numbers separated by commas (e.g., 7,19,20,21,22,29):');
      const additional = prompt('Enter the additional number:');
      
      if (numbers && additional) {
        try {
          const winningNumbers = numbers.split(',').map(n => parseInt(n.trim()));
          const additionalNumber = parseInt(additional.trim());
          
          if (winningNumbers.length !== 6 || winningNumbers.some(n => isNaN(n) || n < 1 || n > 49)) {
            throw new Error('Invalid winning numbers');
          }
          
          if (isNaN(additionalNumber) || additionalNumber < 1 || additionalNumber > 49) {
            throw new Error('Invalid additional number');
          }
          
          updateLatestResult(winningNumbers, additionalNumber);
          
          // Update the historical data array
          const newResult = [...winningNumbers, additionalNumber];
          historical.unshift(newResult);
          
          // Auto-select the new result
          ['base1', 'base2', 'base3', 'base4', 'base5', 'base6'].forEach((id, idx) => {
            document.getElementById(id).value = winningNumbers[idx];
          });
          document.getElementById('additional').value = additionalNumber;
          
          alert('Results updated successfully! (Note: This is temporary - GitHub Action will provide permanent updates)');
          
        } catch (error) {
          alert('Error: ' + error.message);
        }
      }
    }
    
    // Function to update the display of latest results
    function updateLatestResult(winningNumbers, additionalNumber) {
      const resultText = `${winningNumbers.join(',')}(${additionalNumber})`;
      const resultElement = document.getElementById('recentResult');
      if (resultElement) {
        resultElement.textContent = `RECENT RESULT: ${resultText}`;
      }
    }
    
    let chartInstance = null;

    function predict() {
      const hasHistoricalMatch = checkHistoricalAndMaybePredict();
      if (!hasHistoricalMatch) {
        runFrequencyCompatibilityPrediction();
      }
    }

function checkHistoricalAndMaybePredict() {
  const bases = getSelectedBases().sort((a, b) => a - b);
  const mostRecentDraw = historical[0].slice(0, 6).sort((a, b) => a - b);

  // ✅ Skip historical prediction entirely if base = most recent draw
  if (arraysEqual(bases, mostRecentDraw)) {
    return false;
  }

  for (let i = historical.length - 1; i > 0; i--) {
    const draw = historical[i].slice(0, 6).sort((a, b) => a - b);

    // This only prevents matching the most recent draw as a historical case
    if (arraysEqual(draw, mostRecentDraw)) {
      continue;
    }

    if (arraysEqual(draw, bases)) {
      const prevDraw = historical[i - 1];
      calculateScoresAndDisplay(prevDraw.slice(0, 6), prevDraw[6]);
      return true;
    }
  }

  return false;
}

    function getSelectedBases() {
      return ['base1', 'base2', 'base3', 'base4', 'base5', 'base6']
        .map(id => parseInt(document.getElementById(id).value))
        .sort((a, b) => a - b);
    }

    function arraysEqual(a, b) {
      return a.length === b.length && a.every((val, index) => val === b[index]);
    }

    function calculateScoresAndDisplay(numbers, additional = null) {
      const bases = numbers.slice();
      const range = parseInt(document.getElementById('drawRange').value);
      const includeAdd = document.getElementById('includeAdd').checked;
      const draws = historical.slice(0, range);
      const freq = Array(50).fill(0);
      const compat = Array(50).fill(0);

      draws.forEach(draw => {
        const pool = includeAdd ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
        pool.forEach(n => freq[n]++);
        bases.forEach(b => {
          if (pool.includes(b)) {
            pool.filter(n => n !== b).forEach(n => compat[n]++);
          }
        });
      });

      const scores = numbers.map(n => freq[n] + compat[n]);
      console.log('Sanity Check - Predicted Numbers:');
      numbers.forEach((n, i) => {
        console.log(`Number ${n} -> Frequency: ${freq[n]}, Compatibility: ${compat[n]}, Total Score: ${scores[i]}`);
      });
      displayPredictedNumbers(numbers, additional, scores, freq, compat);
    }

    function runFrequencyCompatibilityPrediction() {
      const bases = getSelectedBases();
      const range = parseInt(document.getElementById('drawRange').value);
      const includeAdd = document.getElementById('includeAdd').checked;
      const draws = historical.slice(0, range);
      const freq = Array(50).fill(0);
      const compat = Array(50).fill(0);

      draws.forEach(draw => {
        const pool = includeAdd ? draw.slice(0, 6).concat(draw[6]) : draw.slice(0, 6);
        pool.forEach(n => freq[n]++);
        bases.forEach(b => {
          if (pool.includes(b)) {
            pool.filter(n => n !== b).forEach(n => compat[n]++);
          }
        });
      });

      const suggestions = freq
        .map((count, n) => ({ n, count, compat: compat[n] }))
        .filter(o => o.n)
        .sort((a, b) => (b.compat + b.count) - (a.compat + a.count) || b.count - a.count || a.n - b.n)
        .slice(0, 6);

      const scores = suggestions.map(o => o.count + o.compat);
      console.log('Sanity Check - Suggestions:');
      suggestions.forEach((o, i) => {
        console.log(`Number ${o.n} -> Frequency: ${o.count}, Compatibility: ${o.compat}, Total Score: ${scores[i]}`);
      });
      displayPredictedNumbers(suggestions.map(o => o.n), null, scores, freq, compat);
    }

    function displayPredictedNumbers(numbers, additional = null, scores, freq, compat) {
      const rs = document.getElementById('results');
      // Sort numbers, scores, freq, compat for both display and chart
     const sorted = numbers
     .map((n, i) => ({
      n,
      score: scores[i],
      freq: freq[n],
      compat: compat[n]
  }))
  .sort((a, b) => a.n - b.n);  // ✅ ASCENDING ORDER by number
      const sortedNumbers = sorted.map(o => o.n);
      const sortedScores = sorted.map(o => o.score);
      const sortedFreq = sorted.map(o => o.freq);
      const sortedCompat = sorted.map(o => o.compat);
      rs.innerHTML = '<h3>Predicted Numbers:</h3>' +
        `<p>${sortedNumbers.join(', ')}</p>`;

      const ctx = document.getElementById('freqChart').getContext('2d');
      if (chartInstance) {
        chartInstance.destroy();
      }
      chartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: sortedNumbers.map((n, i) => `${n}\n(freq: ${sortedFreq[i]}, compat: ${sortedCompat[i]})`),
          datasets: [{
            label: 'Total Score',
            data: sortedScores,
            backgroundColor: 'rgba(54, 162, 235, 0.6)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  const index = context.dataIndex;
                  return `Freq: ${sortedFreq[index]}, Compat: ${sortedCompat[index]}, Total: ${sortedScores[index]}`;
                }
              }
            }
          },
          scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } } }
        }
      });
    }
  </script>
</body>
</html>